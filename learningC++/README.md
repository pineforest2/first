# Learning C++

学习C++。

**`bst.cc`**

这是一个关于二叉搜索树的实现，对应表示二叉搜索树的类为`BST`，而对应二叉搜索树的结点的类为`Node`。显然类`Node`被嵌套定义在类`BST`内部，并设置为私有，这么做的目的是减少命名冲突😂，并且我们不希望提供关于二叉搜索树结点的任何接口。
类`BST`有一个模板参数，表示“值类型”，而“键类型”为了简便起见直接使用了`int`。进一步来看，其提供的接口。成员函数`empty`和`size`意义是明确的，实现也较简单，就不在此啰嗦了，稍微复杂一点的是成员函数`insert`、`remove`和`search`。
成员函数`insert`的功能是向二叉搜索树中插入键值对。如果二叉搜索树中已存在该键，那么新值会覆盖旧值。如果发生了覆盖情况，该函数会返回0，否则返回1。
成员函数`remove`的功能是从二叉搜索树中删除键值对。这个函数的算法有一点复杂。说明一点，在`insert`中，有两个局部变量`ptr1`和`ptr2`，大体上要维持，`ptr1`指向的结点是`ptr2`指向的结点的双亲。另外，如果`ptr2`指向根节点，那么`ptr1`为空指针。而在`remove`中，这个`ptr1`和`ptr2`的关系也存在，并且还有一个局部变量`flag12`。当`flag12`为1时，`ptr2`指向的结点是`ptr1`的指向的结点的左儿子；当`flag12`为2时，`ptr2`指向的结点是`ptr1`的指向的结点的右儿子。如果该函数实际并未删除任何键值对（二叉搜索树中不存在该键），则返回0，否则返回1。
这里详细地阐述一下，代码中`remove`的逻辑。首先肯定是根据输入的键在树上找键值对，可能找不到，这种情况很好处理，直接返回0即可。如果找到了，进一步看这个待删结点的子树。如果待删结点无子树，则直接将待删结点从二叉搜索树上“摘掉”即可。如果待删结点只有一棵子树，则先将待删结点“摘掉”，然后将该剩下的子树“拼接”上去即可。如果待删结点有两棵子树，则有两种处理方式，一种是从右子树中选出键最小的结点，将其与待删结点“互换”之后，再“摘掉”待删结点；另一种是从左子树中选出键最大的结点，将其与待删结点“互换”之后，再“摘掉”待删结点。
> 这里的“摘掉”、“拼接”和“互换”，只是为了论述方便，实际实现看代码。
> 代码中二叉搜索树键的大小排序是：左儿子 < 根结点 < 右结点。

成员函数`search`的功能是搜索键值对。因为二叉搜索树中可能不存在该键，所以使用了C++17的`std::optional`。如果你是使用`g++`编译，记得加上参数`-std=c++17`或者`-std=gnu++17`。

**`bst2.cc`**

该文件中实现的二叉搜索树行为和接口基本与`bst.cc`中的类似，只是`bst2.cc`中使用的智能指针是`std::unique_ptr`，而在`bst.cc`中使用的智能指针是`std::shared_ptr`。此外`bst2.cc`中的三个主要函数使用了递归实现，这比较符合`std::unique_ptr`的特性。
